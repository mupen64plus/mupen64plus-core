/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *   Mupen64plus - mips_instructions.def                                   *
 *   Mupen64Plus homepage: http://code.google.com/p/mupen64plus/           *
 *   Copyright (C) 2002 Hacktarux                                          *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/* Before #including this file the following macros must be defined:
 *
 * PCADDR: Program counter (memory address of the current instruction).
 *
 * ADD_TO_PC(x): Increment the program counter in 'x' instructions.
 * This is only used for small changes to PC, so the new program counter
 * is guaranteed to fall in the current cached interpreter or dynarec block.
 *
 * DECLARE_INSTRUCTION(name)
 * Declares an instruction function which is not a jump.
 * Followed by a block of code.
 *
 * DECLARE_JUMP(name, destination, condition, link, likely, cop1)
 * name is the name of the jump or branch instruction.
 * destination is the destination memory address of the jump.
 * If condition is nonzero, the jump is taken.
 * link is a pointer to a variable where (PC+8) is written unconditionally.
 *     To avoid linking, pass &reg[0]
 * If likely is nonzero, the delay slot is only executed if the jump is taken.
 * If cop1 is nonzero, a COP1 unusable check will be done.
 *
 * CHECK_MEMORY(): A snippet to be run after a store instruction,
 *                 to check if the store affected executable blocks.
 *                 The memory address of the store is in the 'address' global.
 */

#include "fpu.h"

#include <inttypes.h>
#include <stdint.h>
#include <zlib.h> // For adler32()

/* Assists unaligned memory accessors with making masks to preserve or apply
 * bits in registers and memory.
 *
 * BITS_BELOW_MASK32 and BITS_BELOW_MASK64 make masks where bits 0 to (x - 1)
 * are set.
 *
 * BITS_ABOVE_MASK32 makes masks where bits x to 31 are set.
 * BITS_ABOVE_MASK64 makes masks where bits x to 63 are set.
 *
 * e.g. x = 8
 * 0000 0000 0000 0000 0000 0000 1111 1111 <- BITS_BELOW_MASK32(8)
 * 1111 1111 1111 1111 1111 1111 0000 0000 <- BITS_ABOVE_MASK32(8)
 *
 * Giving a negative value or one that is >= the bit count of the mask results
 * in undefined behavior.
 */

#define BITS_BELOW_MASK32(x) ((UINT32_C(1) << (x)) - 1)
#define BITS_ABOVE_MASK32(x) (~((UINT32_C(1) << (x)) - 1))

#define BITS_BELOW_MASK64(x) ((UINT64_C(1) << (x)) - 1)
#define BITS_ABOVE_MASK64(x) (~((UINT64_C(1) << (x)) - 1))

/* M64P Pseudo instructions */

DECLARE_INSTRUCTION(NI)
{
    DebugMessage(M64MSG_ERROR, "NI() @ 0x%" PRIX32, PCADDR);
    DebugMessage(M64MSG_ERROR, "opcode not implemented: %" PRIX32 ":%" PRIX32, PCADDR, *fast_mem_access(PCADDR));
    *r4300_stop() = 1;
}

/* Reserved */

DECLARE_INSTRUCTION(RESERVED)
{
    DebugMessage(M64MSG_ERROR, "reserved opcode: %" PRIX32 ":%" PRIX32, PCADDR, *fast_mem_access(PCADDR));
    *r4300_stop() = 1;
}

/* Load instructions */

DECLARE_INSTRUCTION(LB)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    *memory_address() = lsaddr;
    g_dev.mem.rdword = (uint64_t*) lsrtp;
    read_byte_in_memory();
    if (*memory_address()) {
        *lsrtp = SE8(*lsrtp);
    }
}

DECLARE_INSTRUCTION(LBU)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    *memory_address() = lsaddr;
    g_dev.mem.rdword = (uint64_t*) lsrtp;
    read_byte_in_memory();
}

DECLARE_INSTRUCTION(LH)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    *memory_address() = lsaddr;
    g_dev.mem.rdword = (uint64_t*) lsrtp;
    read_hword_in_memory();
    if (*memory_address()) {
        *lsrtp = SE16(*lsrtp);
    }
}

DECLARE_INSTRUCTION(LHU)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    *memory_address() = lsaddr;
    g_dev.mem.rdword = (uint64_t*) lsrtp;
    read_hword_in_memory();
}

DECLARE_INSTRUCTION(LL)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    *memory_address() = lsaddr;
    g_dev.mem.rdword = (uint64_t*) lsrtp;
    read_word_in_memory();
    if (*memory_address()) {
        *lsrtp = SE32(*lsrtp);
        g_dev.r4300.llbit = 1;
    }
}

DECLARE_INSTRUCTION(LW)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    *memory_address() = lsaddr;
    g_dev.mem.rdword = (uint64_t*) lsrtp;
    read_word_in_memory();
    if (*memory_address()) {
        *lsrtp = SE32(*lsrtp);
    }
}

DECLARE_INSTRUCTION(LWU)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    *memory_address() = lsaddr;
    g_dev.mem.rdword = (uint64_t*) lsrtp;
    read_word_in_memory();
}

DECLARE_INSTRUCTION(LWL)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    uint64_t word = 0;
    ADD_TO_PC(1);
    if ((lsaddr & 3) == 0)
    {
        *memory_address() = lsaddr;
        g_dev.mem.rdword = (uint64_t*) lsrtp;
        read_word_in_memory();
        if (*memory_address())
            *lsrtp = SE32(*lsrtp);
    }
    else
    {
        *memory_address() = lsaddr & UINT32_C(0xFFFFFFFC);
        g_dev.mem.rdword = &word;
        read_word_in_memory();
        if (*memory_address())
        {
            /* How many low bits do we want to preserve from the old value? */
            uint32_t old_mask = BITS_BELOW_MASK32((lsaddr & 3) * 8);
            /* How many bits up do we want to add the low bits of the new value in? */
            int new_shift = (lsaddr & 3) * 8;
            *lsrtp = SE32(((uint32_t) *lsrtp & old_mask) | ((uint32_t) word << new_shift));
        }
    }
}

DECLARE_INSTRUCTION(LWR)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    uint64_t word = 0;
    ADD_TO_PC(1);
    *memory_address() = lsaddr & UINT32_C(0xFFFFFFFC);
    if ((lsaddr & 3) == 3)
    {
        g_dev.mem.rdword = (uint64_t*) lsrtp;
        read_word_in_memory();
        if (*memory_address()) {
            *lsrtp = SE32(*lsrtp);
        }
    }
    else
    {
        g_dev.mem.rdword = &word;
        read_word_in_memory();
        if (*memory_address())
        {
            /* How many high bits do we want to preserve from the old value? */
            uint32_t old_mask = BITS_ABOVE_MASK32(((lsaddr & 3) + 1) * 8);
            /* How many bits down do we want to add the new value in? */
            int new_shift = (3 - (lsaddr & 3)) * 8;
            *lsrtp = SE32(((uint32_t) *lsrtp & old_mask) | ((uint32_t) word >> new_shift));
        }
    }
}

DECLARE_INSTRUCTION(LD)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    *memory_address() = lsaddr;
    g_dev.mem.rdword = (uint64_t*) lsrtp;
    read_dword_in_memory();
}

DECLARE_INSTRUCTION(LDL)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    uint64_t word = 0;
    ADD_TO_PC(1);
    if ((lsaddr & 7) == 0)
    {
        *memory_address() = lsaddr;
        g_dev.mem.rdword = (uint64_t*) lsrtp;
        read_dword_in_memory();
    }
    else
    {
        *memory_address() = lsaddr & UINT32_C(0xFFFFFFF8);
        g_dev.mem.rdword = &word;
        read_dword_in_memory();
        if (*memory_address())
        {
            /* How many low bits do we want to preserve from the old value? */
            uint64_t old_mask = BITS_BELOW_MASK64((lsaddr & 7) * 8);
            /* How many bits up do we want to add the low bits of the new value in? */
            int new_shift = (lsaddr & 7) * 8;
            *lsrtp = (*lsrtp & old_mask) | (word << new_shift);
        }
    }
}

DECLARE_INSTRUCTION(LDR)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    uint64_t word = 0;
    ADD_TO_PC(1);
    *memory_address() = lsaddr & UINT32_C(0xFFFFFFF8);
    if ((lsaddr & 7) == 7)
    {
        g_dev.mem.rdword = (uint64_t*) lsrtp;
        read_dword_in_memory();
    }
    else
    {
        g_dev.mem.rdword = &word;
        read_dword_in_memory();
        if (*memory_address())
        {
            /* How many high bits do we want to preserve from the old value? */
            uint64_t old_mask = BITS_ABOVE_MASK64(((lsaddr & 7) + 1) * 8);
            /* How many bits down do we want to add the high bits of the new value in? */
            int new_shift = (7 - (lsaddr & 7)) * 8;
            *lsrtp = (*lsrtp & old_mask) | (word >> new_shift);
        }
    }
}

/* Store instructions */

DECLARE_INSTRUCTION(SB)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    *memory_address() = lsaddr;
    *memory_wbyte() = (uint8_t) *lsrtp;
    write_byte_in_memory();
    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SH)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    *memory_address() = lsaddr;
    *memory_whword() = (uint16_t) *lsrtp;
    write_hword_in_memory();
    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SC)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    if(g_dev.r4300.llbit)
    {
        *memory_address() = lsaddr;
        *memory_wword() = (uint32_t) *lsrtp;
        write_word_in_memory();
        CHECK_MEMORY();
        g_dev.r4300.llbit = 0;
        *lsrtp = 1;
    }
    else
    {
        *lsrtp = 0;
    }
}

DECLARE_INSTRUCTION(SW)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    *memory_address() = lsaddr;
    *memory_wword() = (uint32_t) *lsrtp;
    write_word_in_memory();
    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SWL)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    uint64_t old_word = 0;
    ADD_TO_PC(1);
    if ((lsaddr & 3) == 0)
    {
        *memory_address() = lsaddr;
        *memory_wword() = (uint32_t) *lsrtp;
        write_word_in_memory();
        CHECK_MEMORY();
    }
    else
    {
        *memory_address() = lsaddr & UINT32_C(0xFFFFFFFC);
        g_dev.mem.rdword = &old_word;
        read_word_in_memory();
        if (*memory_address())
        {
            /* How many high bits do we want to preserve from what was in memory
             * before? */
            uint32_t old_mask = BITS_ABOVE_MASK32((4 - (lsaddr & 3)) * 8);
            /* How many bits down do we need to shift the register to store some
             * of its high bits into the low bits of the memory word? */
            int new_shift = (lsaddr & 3) * 8;
            *memory_wword() = ((uint32_t) old_word & old_mask) | ((uint32_t) *lsrtp >> new_shift);
            write_word_in_memory();
            CHECK_MEMORY();
        }
    }
}

DECLARE_INSTRUCTION(SWR)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    uint64_t old_word = 0;
    ADD_TO_PC(1);
    *memory_address() = lsaddr & UINT32_C(0xFFFFFFFC);
    if ((lsaddr & 3) == 3)
    {
        *memory_wword() = (uint32_t) *lsrtp;
        write_word_in_memory();
        CHECK_MEMORY();
    }
    else
    {
        g_dev.mem.rdword = &old_word;
        read_word_in_memory();
        if (*memory_address())
        {
            /* How many low bits do we want to preserve from what was in memory
             * before? */
            int32_t old_mask = BITS_BELOW_MASK32((3 - (lsaddr & 3)) * 8);
            /* How many bits up do we need to shift the register to store some
             * of its low bits into the high bits of the memory word? */
            int new_shift = (3 - (lsaddr & 3)) * 8;
            *memory_wword() = ((uint32_t) old_word & old_mask) | ((uint32_t) *lsrtp << new_shift);
            write_word_in_memory();
            CHECK_MEMORY();
        }
    }
}

DECLARE_INSTRUCTION(SD)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    ADD_TO_PC(1);
    *memory_address() = lsaddr;
    *memory_wdword() = *lsrtp;
    write_dword_in_memory();
    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SDL)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    uint64_t old_word = 0;
    ADD_TO_PC(1);
    if ((lsaddr & 7) == 0)
    {
        *memory_address() = lsaddr;
        *memory_wdword() = *lsrtp;
        write_dword_in_memory();
        CHECK_MEMORY();
    }
    else
    {
        *memory_address() = lsaddr & UINT32_C(0xFFFFFFF8);
        g_dev.mem.rdword = &old_word;
        read_dword_in_memory();
        if (*memory_address())
        {
            /* How many high bits do we want to preserve from what was in memory
             * before? */
            uint64_t old_mask = BITS_ABOVE_MASK64((8 - (lsaddr & 7)) * 8);
            /* How many bits down do we need to shift the register to store some
             * of its high bits into the low bits of the memory word? */
            int new_shift = (lsaddr & 7) * 8;
            *memory_wdword() = (old_word & old_mask) | ((uint64_t) *lsrtp >> new_shift);
            write_dword_in_memory();
            CHECK_MEMORY();
        }
    }
}

DECLARE_INSTRUCTION(SDR)
{
    const uint32_t lsaddr = irs32 + iimmediate;
    int64_t *lsrtp = &irt;
    uint64_t old_word = 0;
    ADD_TO_PC(1);
    *memory_address() = lsaddr & UINT32_C(0xFFFFFFF8);
    if ((lsaddr & 7) == 7)
    {
        *memory_wdword() = *lsrtp;
        write_dword_in_memory();
        CHECK_MEMORY();
    }
    else
    {
        g_dev.mem.rdword = &old_word;
        read_dword_in_memory();
        if (*memory_address())
        {
            /* How many low bits do we want to preserve from what was in memory
             * before? */
            uint64_t old_mask = BITS_BELOW_MASK64((7 - (lsaddr & 7)) * 8);
            /* How many bits up do we need to shift the register to store some
             * of its low bits into the high bits of the memory word? */
            int new_shift = (7 - (lsaddr & 7)) * 8;
            *memory_wdword() = (old_word & old_mask) | (*lsrtp << new_shift);
            write_dword_in_memory();
            CHECK_MEMORY();
        }
    }
}

/* Computational instructions */

DECLARE_INSTRUCTION(ADD)
{
    rrd = SE32(rrs32 + rrt32);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ADDU)
{
    rrd = SE32(rrs32 + rrt32);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ADDI)
{
    irt = SE32(irs32 + iimmediate);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ADDIU)
{
    irt = SE32(irs32 + iimmediate);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DADD)
{
    rrd = rrs + rrt;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DADDU)
{
    rrd = rrs + rrt;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DADDI)
{
    irt = irs + iimmediate;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DADDIU)
{
    irt = irs + iimmediate;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SUB)
{
    rrd = SE32(rrs32 - rrt32);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SUBU)
{
    rrd = SE32(rrs32 - rrt32);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DSUB)
{
    rrd = rrs - rrt;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DSUBU)
{
    rrd = rrs - rrt;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SLT)
{
    if (rrs < rrt) { rrd = 1; }
    else { rrd = 0; }
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SLTU)
{
    if ((uint64_t) rrs < (uint64_t) rrt) { rrd = 1; }
    else { rrd = 0; }
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SLTI)
{
    if (irs < iimmediate) { irt = 1; }
    else { irt = 0; }
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SLTIU)
{
    if ((uint64_t) irs < (uint64_t) ((int64_t) iimmediate)) { irt = 1; }
    else { irt = 0; }
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(AND)
{
    rrd = rrs & rrt;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ANDI)
{
    irt = irs & (uint16_t) iimmediate;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(OR)
{
    rrd = rrs | rrt;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ORI)
{
    irt = irs | (uint16_t) iimmediate;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(XOR)
{
    rrd = rrs ^ rrt;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(XORI)
{
    irt = irs ^ (uint16_t) iimmediate;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(NOR)
{
    rrd = ~(rrs | rrt);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(LUI)
{
    irt = SE32(iimmediate << 16);
    ADD_TO_PC(1);
}

/* Shift instructions */

DECLARE_INSTRUCTION(NOP)
{
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SLL)
{
    rrd = SE32((uint32_t) rrt32 << rsa);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SLLV)
{
    rrd = SE32((uint32_t) rrt32 << (rrs32 & 0x1F));
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DSLL)
{
    rrd = rrt << rsa;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DSLLV)
{
    rrd = rrt << (rrs32 & 0x3F);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DSLL32)
{
    rrd = rrt << (32 + rsa);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SRL)
{
    rrd = SE32((uint32_t) rrt32 >> rsa);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SRLV)
{
    rrd = SE32((uint32_t) rrt32 >> (rrs32 & 0x1F));
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DSRL)
{
    rrd = (uint64_t) rrt >> rsa;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DSRLV)
{
    rrd = (uint64_t) rrt >> (rrs32 & 0x3F);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DSRL32)
{
    rrd = (uint64_t) rrt >> (32 + rsa);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SRA)
{
    rrd = SE32((int32_t) rrt32 >> rsa);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SRAV)
{
    rrd = SE32((int32_t) rrt32 >> (rrs32 & 0x1F));
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DSRA)
{
    rrd = rrt >> rsa;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DSRAV)
{
    rrd = (int64_t) rrt >> (rrs32 & 0x3F);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DSRA32)
{
    rrd = (int64_t) rrt >> (32 + rsa);
    ADD_TO_PC(1);
}

/* Multiply / Divide instructions */

DECLARE_INSTRUCTION(MULT)
{
    int64_t temp;
    temp = rrs * rrt;
    *r4300_mult_hi() = temp >> 32;
    *r4300_mult_lo() = SE32(temp);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(MULTU)
{
    uint64_t temp;
    temp = (uint32_t) rrs * (uint64_t) ((uint32_t) rrt);
    *r4300_mult_hi() = (int64_t) temp >> 32;
    *r4300_mult_lo() = SE32(temp);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DMULT)
{
    uint64_t op1, op2, op3, op4;
    uint64_t result1, result2, result3, result4;
    uint64_t temp1, temp2, temp3, temp4;
    int sign = 0;

    if (rrs < 0)
    {
        op2 = -rrs;
        sign = 1 - sign;
    }
    else { op2 = rrs; }
    if (rrt < 0)
    {
        op4 = -rrt;
        sign = 1 - sign;
    }
    else { op4 = rrt; }

    op1 = op2 & UINT64_C(0xFFFFFFFF);
    op2 = (op2 >> 32) & UINT64_C(0xFFFFFFFF);
    op3 = op4 & UINT64_C(0xFFFFFFFF);
    op4 = (op4 >> 32) & UINT64_C(0xFFFFFFFF);

    temp1 = op1 * op3;
    temp2 = (temp1 >> 32) + op1 * op4;
    temp3 = op2 * op3;
    temp4 = (temp3 >> 32) + op2 * op4;

    result1 = temp1 & UINT64_C(0xFFFFFFFF);
    result2 = temp2 + (temp3 & UINT64_C(0xFFFFFFFF));
    result3 = (result2 >> 32) + temp4;
    result4 = (result3 >> 32);

    *r4300_mult_lo() = result1 | (result2 << 32);
    *r4300_mult_hi() = (result3 & UINT64_C(0xFFFFFFFF)) | (result4 << 32);
    if (sign)
    {
        *r4300_mult_hi() = ~*r4300_mult_hi();
        if (!*r4300_mult_lo()) { (*r4300_mult_hi())++; }
        else { *r4300_mult_lo() = ~*r4300_mult_lo() + 1; }
    }
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DMULTU)
{
    uint64_t op1, op2, op3, op4;
    uint64_t result1, result2, result3, result4;
    uint64_t temp1, temp2, temp3, temp4;

    op1 = rrs & UINT64_C(0xFFFFFFFF);
    op2 = (rrs >> 32) & UINT64_C(0xFFFFFFFF);
    op3 = rrt & UINT64_C(0xFFFFFFFF);
    op4 = (rrt >> 32) & UINT64_C(0xFFFFFFFF);

    temp1 = op1 * op3;
    temp2 = (temp1 >> 32) + op1 * op4;
    temp3 = op2 * op3;
    temp4 = (temp3 >> 32) + op2 * op4;

    result1 = temp1 & UINT64_C(0xFFFFFFFF);
    result2 = temp2 + (temp3 & UINT64_C(0xFFFFFFFF));
    result3 = (result2 >> 32) + temp4;
    result4 = (result3 >> 32);

    *r4300_mult_lo() = result1 | (result2 << 32);
    *r4300_mult_hi() = (result3 & UINT64_C(0xFFFFFFFF)) | (result4 << 32);

    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DIV)
{
    if (rrt32)
    {
        *r4300_mult_lo() = SE32(rrs32 / rrt32);
        *r4300_mult_hi() = SE32(rrs32 % rrt32);
    }
    else { DebugMessage(M64MSG_ERROR, "DIV: divide by 0"); }
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DIVU)
{
    if (rrt32)
    {
        *r4300_mult_lo() = SE32((uint32_t) rrs32 / (uint32_t) rrt32);
        *r4300_mult_hi() = SE32((uint32_t) rrs32 % (uint32_t) rrt32);
    }
    else { DebugMessage(M64MSG_ERROR, "DIVU: divide by 0"); }
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DDIV)
{
    if (rrt)
    {
        *r4300_mult_lo() = rrs / rrt;
        *r4300_mult_hi() = rrs % rrt;
    }
    else { DebugMessage(M64MSG_ERROR, "DDIV: divide by 0"); }
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DDIVU)
{
    if (rrt)
    {
        *r4300_mult_lo() = (uint64_t) rrs / (uint64_t) rrt;
        *r4300_mult_hi() = (uint64_t) rrs % (uint64_t) rrt;
    }
    else { DebugMessage(M64MSG_ERROR, "DDIVU: divide by 0"); }
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(MFHI)
{
    rrd = *r4300_mult_hi();
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(MTHI)
{
    *r4300_mult_hi() = rrs;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(MFLO)
{
    rrd = *r4300_mult_lo();
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(MTLO)
{
    *r4300_mult_lo() = rrs;
    ADD_TO_PC(1);
}

/* Jump & Branch instructions */

DECLARE_JUMP(J,   (jinst_index<<2) | ((PCADDR+4) & UINT32_C(0xF0000000)), 1, &r4300_regs()[0],  0, 0)
DECLARE_JUMP(JAL, (jinst_index<<2) | ((PCADDR+4) & UINT32_C(0xF0000000)), 1, &r4300_regs()[31], 0, 0)

DECLARE_JUMP(JR,   irs32, 1, &r4300_regs()[0], 0, 0)
DECLARE_JUMP(JALR, irs32, 1, &rrd,    0, 0)

DECLARE_JUMP(BEQ,     PCADDR + (iimmediate+1)*4, irs == irt, &r4300_regs()[0], 0, 0)
DECLARE_JUMP(BEQL,    PCADDR + (iimmediate+1)*4, irs == irt, &r4300_regs()[0], 1, 0)

DECLARE_JUMP(BNE,     PCADDR + (iimmediate+1)*4, irs != irt, &r4300_regs()[0], 0, 0)
DECLARE_JUMP(BNEL,    PCADDR + (iimmediate+1)*4, irs != irt, &r4300_regs()[0], 1, 0)

DECLARE_JUMP(BLEZ,    PCADDR + (iimmediate+1)*4, irs <= 0,   &r4300_regs()[0], 0, 0)
DECLARE_JUMP(BLEZL,   PCADDR + (iimmediate+1)*4, irs <= 0,   &r4300_regs()[0], 1, 0)

DECLARE_JUMP(BGTZ,    PCADDR + (iimmediate+1)*4, irs > 0,    &r4300_regs()[0], 0, 0)
DECLARE_JUMP(BGTZL,   PCADDR + (iimmediate+1)*4, irs > 0,    &r4300_regs()[0], 1, 0)

DECLARE_JUMP(BLTZ,    PCADDR + (iimmediate+1)*4, irs < 0,    &r4300_regs()[0],  0, 0)
DECLARE_JUMP(BLTZAL,  PCADDR + (iimmediate+1)*4, irs < 0,    &r4300_regs()[31], 0, 0)
DECLARE_JUMP(BLTZL,   PCADDR + (iimmediate+1)*4, irs < 0,    &r4300_regs()[0],  1, 0)
DECLARE_JUMP(BLTZALL, PCADDR + (iimmediate+1)*4, irs < 0,    &r4300_regs()[31], 1, 0)

DECLARE_JUMP(BGEZ,    PCADDR + (iimmediate+1)*4, irs >= 0,   &r4300_regs()[0],  0, 0)
DECLARE_JUMP(BGEZAL,  PCADDR + (iimmediate+1)*4, irs >= 0,   &r4300_regs()[31], 0, 0)
DECLARE_JUMP(BGEZL,   PCADDR + (iimmediate+1)*4, irs >= 0,   &r4300_regs()[0],  1, 0)
DECLARE_JUMP(BGEZALL, PCADDR + (iimmediate+1)*4, irs >= 0,   &r4300_regs()[31], 1, 0)

DECLARE_JUMP(BC1F,  PCADDR + (iimmediate+1)*4, ((*r4300_cp1_fcr31()) & FCR31_CMP_BIT)==0, &r4300_regs()[0], 0, 1)
DECLARE_JUMP(BC1FL, PCADDR + (iimmediate+1)*4, ((*r4300_cp1_fcr31()) & FCR31_CMP_BIT)==0, &r4300_regs()[0], 1, 1)
DECLARE_JUMP(BC1T,  PCADDR + (iimmediate+1)*4, ((*r4300_cp1_fcr31()) & FCR31_CMP_BIT)!=0, &r4300_regs()[0], 0, 1)
DECLARE_JUMP(BC1TL, PCADDR + (iimmediate+1)*4, ((*r4300_cp1_fcr31()) & FCR31_CMP_BIT)!=0, &r4300_regs()[0], 1, 1)

/* Special instructions */

DECLARE_INSTRUCTION(CACHE)
{
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ERET)
{
    uint32_t* cp0_regs = r4300_cp0_regs();
    unsigned int* cp0_next_interrupt = r4300_cp0_next_interrupt();

    cp0_update_count();
    if (cp0_regs[CP0_STATUS_REG] & CP0_STATUS_ERL)
    {
        DebugMessage(M64MSG_ERROR, "error in ERET");
        *r4300_stop()=1;
    }
    else
    {
        cp0_regs[CP0_STATUS_REG] &= ~CP0_STATUS_EXL;
        generic_jump_to(&g_dev.r4300, cp0_regs[CP0_EPC_REG]);
    }
    g_dev.r4300.llbit = 0;
    check_interrupt(&g_dev.r4300);
    g_dev.r4300.cp0.last_addr = PCADDR;
    if (*cp0_next_interrupt <= cp0_regs[CP0_COUNT_REG]) { gen_interrupt(); }
}

DECLARE_INSTRUCTION(SYNC)
{
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SYSCALL)
{
    uint32_t* cp0_regs = r4300_cp0_regs();

    cp0_regs[CP0_CAUSE_REG] = CP0_CAUSE_EXCCODE_SYS;
    exception_general(&g_dev.r4300);
}

/* Exception instructions */

DECLARE_INSTRUCTION(TEQ)
{
    if (rrs == rrt)
    {
        DebugMessage(M64MSG_ERROR, "trap exception in TEQ");
        *r4300_stop()=1;
    }
    ADD_TO_PC(1);
}

/* TLB instructions */

DECLARE_INSTRUCTION(TLBP)
{
    int i;
    uint32_t* cp0_regs = r4300_cp0_regs();

    cp0_regs[CP0_INDEX_REG] |= UINT32_C(0x80000000);
    for (i = 0; i < 32; ++i)
    {
        if (((g_dev.r4300.cp0.tlb.entries[i].vpn2 & (~g_dev.r4300.cp0.tlb.entries[i].mask)) ==
                    (((cp0_regs[CP0_ENTRYHI_REG] & UINT32_C(0xFFFFE000)) >> 13) & (~g_dev.r4300.cp0.tlb.entries[i].mask))) &&
                ((g_dev.r4300.cp0.tlb.entries[i].g) ||
                 (g_dev.r4300.cp0.tlb.entries[i].asid == (cp0_regs[CP0_ENTRYHI_REG] & UINT32_C(0xFF)))))
        {
            cp0_regs[CP0_INDEX_REG] = i;
            break;
        }
    }
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(TLBR)
{
    uint32_t* cp0_regs = r4300_cp0_regs();

    int index;
    index = cp0_regs[CP0_INDEX_REG] & UINT32_C(0x1F);
    cp0_regs[CP0_PAGEMASK_REG] = g_dev.r4300.cp0.tlb.entries[index].mask << 13;
    cp0_regs[CP0_ENTRYHI_REG] = ((g_dev.r4300.cp0.tlb.entries[index].vpn2 << 13) | g_dev.r4300.cp0.tlb.entries[index].asid);
    cp0_regs[CP0_ENTRYLO0_REG] = (g_dev.r4300.cp0.tlb.entries[index].pfn_even << 6) | (g_dev.r4300.cp0.tlb.entries[index].c_even << 3)
        | (g_dev.r4300.cp0.tlb.entries[index].d_even << 2) | (g_dev.r4300.cp0.tlb.entries[index].v_even << 1)
        | g_dev.r4300.cp0.tlb.entries[index].g;
    cp0_regs[CP0_ENTRYLO1_REG] = (g_dev.r4300.cp0.tlb.entries[index].pfn_odd << 6) | (g_dev.r4300.cp0.tlb.entries[index].c_odd << 3)
        | (g_dev.r4300.cp0.tlb.entries[index].d_odd << 2) | (g_dev.r4300.cp0.tlb.entries[index].v_odd << 1)
        | g_dev.r4300.cp0.tlb.entries[index].g;
    ADD_TO_PC(1);
}

static void TLBWrite(unsigned int idx)
{
    uint32_t* cp0_regs = r4300_cp0_regs();

    if (g_dev.r4300.emumode != EMUMODE_PURE_INTERPRETER)
    {
        unsigned int i;
        if (g_dev.r4300.cp0.tlb.entries[idx].v_even)
        {
            for (i=g_dev.r4300.cp0.tlb.entries[idx].start_even>>12; i<=g_dev.r4300.cp0.tlb.entries[idx].end_even>>12; i++)
            {
                if(!g_dev.r4300.cached_interp.invalid_code[i] &&(g_dev.r4300.cached_interp.invalid_code[g_dev.r4300.cp0.tlb.LUT_r[i]>>12] ||
                            g_dev.r4300.cached_interp.invalid_code[(g_dev.r4300.cp0.tlb.LUT_r[i]>>12)+0x20000])) {
                    g_dev.r4300.cached_interp.invalid_code[i] = 1;
                }
                if (!g_dev.r4300.cached_interp.invalid_code[i])
                {
                    /*int j;
                      md5_state_t state;
                      md5_byte_t digest[16];
                      md5_init(&state);
                      md5_append(&state,
                      (const md5_byte_t*)&g_dev.ri.rdram.dram[(g_dev.r4300.cp0.tlb.LUT_r[i]&0x7FF000)/4],
                      0x1000);
                      md5_finish(&state, digest);
                      for (j=0; j<16; j++) g_dev.r4300.cached_interp.blocks[i]->md5[j] = digest[j];*/

                    g_dev.r4300.cached_interp.blocks[i]->adler32 = adler32(0, (const unsigned char *)&g_dev.ri.rdram.dram[(g_dev.r4300.cp0.tlb.LUT_r[i]&0x7FF000)/4], 0x1000);

                    g_dev.r4300.cached_interp.invalid_code[i] = 1;
                }
                else if (g_dev.r4300.cached_interp.blocks[i])
                {
                    /*int j;
                      for (j=0; j<16; j++) g_dev.r4300.cached_interp.blocks[i]->md5[j] = 0;*/
                    g_dev.r4300.cached_interp.blocks[i]->adler32 = 0;
                }
            }
        }
        if (g_dev.r4300.cp0.tlb.entries[idx].v_odd)
        {
            for (i=g_dev.r4300.cp0.tlb.entries[idx].start_odd>>12; i<=g_dev.r4300.cp0.tlb.entries[idx].end_odd>>12; i++)
            {
                if(!g_dev.r4300.cached_interp.invalid_code[i] &&(g_dev.r4300.cached_interp.invalid_code[g_dev.r4300.cp0.tlb.LUT_r[i]>>12] ||
                            g_dev.r4300.cached_interp.invalid_code[(g_dev.r4300.cp0.tlb.LUT_r[i]>>12)+0x20000])) {
                    g_dev.r4300.cached_interp.invalid_code[i] = 1;
                }
                if (!g_dev.r4300.cached_interp.invalid_code[i])
                {
                    /*int j;
                      md5_state_t state;
                      md5_byte_t digest[16];
                      md5_init(&state);
                      md5_append(&state,
                      (const md5_byte_t*)&g_dev.ri.rdram.dram[(g_dev.r4300.cp0.tlb.LUT_r[i]&0x7FF000)/4],
                      0x1000);
                      md5_finish(&state, digest);
                      for (j=0; j<16; j++) g_dev.r4300.cached_interp.blocks[i]->md5[j] = digest[j];*/

                    g_dev.r4300.cached_interp.blocks[i]->adler32 = adler32(0, (const unsigned char *)&g_dev.ri.rdram.dram[(g_dev.r4300.cp0.tlb.LUT_r[i]&0x7FF000)/4], 0x1000);

                    g_dev.r4300.cached_interp.invalid_code[i] = 1;
                }
                else if (g_dev.r4300.cached_interp.blocks[i])
                {
                    /*int j;
                      for (j=0; j<16; j++) g_dev.r4300.cached_interp.blocks[i]->md5[j] = 0;*/
                    g_dev.r4300.cached_interp.blocks[i]->adler32 = 0;
                }
            }
        }
    }

    tlb_unmap(&g_dev.r4300.cp0.tlb, idx);

    g_dev.r4300.cp0.tlb.entries[idx].g = (cp0_regs[CP0_ENTRYLO0_REG] & cp0_regs[CP0_ENTRYLO1_REG] & 1);
    g_dev.r4300.cp0.tlb.entries[idx].pfn_even = (cp0_regs[CP0_ENTRYLO0_REG] & UINT32_C(0x3FFFFFC0)) >> 6;
    g_dev.r4300.cp0.tlb.entries[idx].pfn_odd = (cp0_regs[CP0_ENTRYLO1_REG] & UINT32_C(0x3FFFFFC0)) >> 6;
    g_dev.r4300.cp0.tlb.entries[idx].c_even = (cp0_regs[CP0_ENTRYLO0_REG] & UINT32_C(0x38)) >> 3;
    g_dev.r4300.cp0.tlb.entries[idx].c_odd = (cp0_regs[CP0_ENTRYLO1_REG] & UINT32_C(0x38)) >> 3;
    g_dev.r4300.cp0.tlb.entries[idx].d_even = (cp0_regs[CP0_ENTRYLO0_REG] & UINT32_C(0x4)) >> 2;
    g_dev.r4300.cp0.tlb.entries[idx].d_odd = (cp0_regs[CP0_ENTRYLO1_REG] & UINT32_C(0x4)) >> 2;
    g_dev.r4300.cp0.tlb.entries[idx].v_even = (cp0_regs[CP0_ENTRYLO0_REG] & UINT32_C(0x2)) >> 1;
    g_dev.r4300.cp0.tlb.entries[idx].v_odd = (cp0_regs[CP0_ENTRYLO1_REG] & UINT32_C(0x2)) >> 1;
    g_dev.r4300.cp0.tlb.entries[idx].asid = (cp0_regs[CP0_ENTRYHI_REG] & UINT32_C(0xFF));
    g_dev.r4300.cp0.tlb.entries[idx].vpn2 = (cp0_regs[CP0_ENTRYHI_REG] & UINT32_C(0xFFFFE000)) >> 13;
    //g_dev.r4300.cp0.tlb.entries[idx].r = (cp0_regs[CP0_ENTRYHI_REG] & 0xC000000000000000LL) >> 62;
    g_dev.r4300.cp0.tlb.entries[idx].mask = (cp0_regs[CP0_PAGEMASK_REG] & UINT32_C(0x1FFE000)) >> 13;

    g_dev.r4300.cp0.tlb.entries[idx].start_even = g_dev.r4300.cp0.tlb.entries[idx].vpn2 << 13;
    g_dev.r4300.cp0.tlb.entries[idx].end_even = g_dev.r4300.cp0.tlb.entries[idx].start_even+
        (g_dev.r4300.cp0.tlb.entries[idx].mask << 12) + UINT32_C(0xFFF);
    g_dev.r4300.cp0.tlb.entries[idx].phys_even = g_dev.r4300.cp0.tlb.entries[idx].pfn_even << 12;


    g_dev.r4300.cp0.tlb.entries[idx].start_odd = g_dev.r4300.cp0.tlb.entries[idx].end_even+1;
    g_dev.r4300.cp0.tlb.entries[idx].end_odd = g_dev.r4300.cp0.tlb.entries[idx].start_odd+
        (g_dev.r4300.cp0.tlb.entries[idx].mask << 12) + UINT32_C(0xFFF);
    g_dev.r4300.cp0.tlb.entries[idx].phys_odd = g_dev.r4300.cp0.tlb.entries[idx].pfn_odd << 12;

    tlb_map(&g_dev.r4300.cp0.tlb, idx);

    if (g_dev.r4300.emumode != EMUMODE_PURE_INTERPRETER)
    {
        unsigned int i;
        if (g_dev.r4300.cp0.tlb.entries[idx].v_even)
        {
            for (i=g_dev.r4300.cp0.tlb.entries[idx].start_even>>12; i<=g_dev.r4300.cp0.tlb.entries[idx].end_even>>12; i++)
            {
                /*if (g_dev.r4300.cached_interp.blocks[i] && (g_dev.r4300.cached_interp.blocks[i]->md5[0] || g_dev.r4300.cached_interp.blocks[i]->md5[1] ||
                  g_dev.r4300.cached_interp.blocks[i]->md5[2] || g_dev.r4300.cached_interp.blocks[i]->md5[3]))
                  {
                  int j;
                  int equal = 1;
                  md5_state_t state;
                  md5_byte_t digest[16];
                  md5_init(&state);
                  md5_append(&state,
                  (const md5_byte_t*)&g_dev.ri.rdram.dram[(g_dev.r4300.cp0.tlb.LUT_r[i]&0x7FF000)/4],
                  0x1000);
                  md5_finish(&state, digest);
                  for (j=0; j<16; j++)
                  if (digest[j] != g_dev.r4300.cached_interp.blocks[i]->md5[j])
                  equal = 0;
                  if (equal) g_dev.r4300.cached_interp.invalid_code[i] = 0;
                  }*/
                if(g_dev.r4300.cached_interp.blocks[i] && g_dev.r4300.cached_interp.blocks[i]->adler32)
                {
                    if(g_dev.r4300.cached_interp.blocks[i]->adler32 == adler32(0,(const unsigned char *)&g_dev.ri.rdram.dram[(g_dev.r4300.cp0.tlb.LUT_r[i]&0x7FF000)/4],0x1000)) {
                        g_dev.r4300.cached_interp.invalid_code[i] = 0;
                    }
                }
            }
        }

        if (g_dev.r4300.cp0.tlb.entries[idx].v_odd)
        {
            for (i=g_dev.r4300.cp0.tlb.entries[idx].start_odd>>12; i<=g_dev.r4300.cp0.tlb.entries[idx].end_odd>>12; i++)
            {
                /*if (g_dev.r4300.cached_interp.blocks[i] && (g_dev.r4300.cached_interp.blocks[i]->md5[0] || g_dev.r4300.cached_interp.blocks[i]->md5[1] ||
                  g_dev.r4300.cached_interp.blocks[i]->md5[2] || g_dev.r4300.cached_interp.blocks[i]->md5[3]))
                  {
                  int j;
                  int equal = 1;
                  md5_state_t state;
                  md5_byte_t digest[16];
                  md5_init(&state);
                  md5_append(&state,
                  (const md5_byte_t*)&g_dev.ri.rdram.dram[(g_dev.r4300.cp0.tlb.LUT_r[i]&0x7FF000)/4],
                  0x1000);
                  md5_finish(&state, digest);
                  for (j=0; j<16; j++)
                  if (digest[j] != g_dev.r4300.cached_interp.blocks[i]->md5[j])
                  equal = 0;
                  if (equal) g_dev.r4300.cached_interp.invalid_code[i] = 0;
                  }*/
                if(g_dev.r4300.cached_interp.blocks[i] && g_dev.r4300.cached_interp.blocks[i]->adler32)
                {
                    if(g_dev.r4300.cached_interp.blocks[i]->adler32 == adler32(0,(const unsigned char *)&g_dev.ri.rdram.dram[(g_dev.r4300.cp0.tlb.LUT_r[i]&0x7FF000)/4],0x1000)) {
                        g_dev.r4300.cached_interp.invalid_code[i] = 0;
                    }
                }
            }
        }
    }
}

DECLARE_INSTRUCTION(TLBWR)
{
    uint32_t* cp0_regs = r4300_cp0_regs();
    cp0_update_count();
    cp0_regs[CP0_RANDOM_REG] = (cp0_regs[CP0_COUNT_REG]/2 % (32 - cp0_regs[CP0_WIRED_REG]))
        + cp0_regs[CP0_WIRED_REG];
    TLBWrite(cp0_regs[CP0_RANDOM_REG]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(TLBWI)
{
    uint32_t* cp0_regs = r4300_cp0_regs();

    TLBWrite(cp0_regs[CP0_INDEX_REG] & UINT32_C(0x3F));
    ADD_TO_PC(1);
}

/* CP0 load/store instructions */

DECLARE_INSTRUCTION(MFC0)
{
    uint32_t* cp0_regs = r4300_cp0_regs();

    switch(rfs)
    {
    case CP0_RANDOM_REG:
        DebugMessage(M64MSG_ERROR, "MFC0 instruction reading un-implemented Random register");
        *r4300_stop()=1;
        break;
    case CP0_COUNT_REG:
        cp0_update_count();
        /* fall through */
    default:
        rrt = SE32(cp0_regs[rfs]);
    }
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(MTC0)
{
    uint32_t* cp0_regs = r4300_cp0_regs();
    unsigned int* cp0_next_interrupt = r4300_cp0_next_interrupt();

    switch(rfs)
    {
    case CP0_INDEX_REG:
        cp0_regs[CP0_INDEX_REG] = rrt32 & UINT32_C(0x8000003F);
        if ((cp0_regs[CP0_INDEX_REG] & UINT32_C(0x3F)) > UINT32_C(31))
        {
            DebugMessage(M64MSG_ERROR, "MTC0 instruction writing Index register with TLB index > 31");
            *r4300_stop()=1;
        }
        break;
    case CP0_RANDOM_REG:
        break;
    case CP0_ENTRYLO0_REG:
        cp0_regs[CP0_ENTRYLO0_REG] = rrt32 & UINT32_C(0x3FFFFFFF);
        break;
    case CP0_ENTRYLO1_REG:
        cp0_regs[CP0_ENTRYLO1_REG] = rrt32 & UINT32_C(0x3FFFFFFF);
        break;
    case CP0_CONTEXT_REG:
        cp0_regs[CP0_CONTEXT_REG] = (rrt32 & UINT32_C(0xFF800000))
            | (cp0_regs[CP0_CONTEXT_REG] & UINT32_C(0x007FFFF0));
        break;
    case CP0_PAGEMASK_REG:
        cp0_regs[CP0_PAGEMASK_REG] = rrt32 & UINT32_C(0x01FFE000);
        break;
    case CP0_WIRED_REG:
        cp0_regs[CP0_WIRED_REG] = rrt32;
        cp0_regs[CP0_RANDOM_REG] = UINT32_C(31);
        break;
    case CP0_BADVADDR_REG:
        break;
    case CP0_COUNT_REG:
        cp0_update_count();
        g_dev.r4300.cp0.interrupt_unsafe_state = 1;
        if (*cp0_next_interrupt <= cp0_regs[CP0_COUNT_REG]) { gen_interrupt(); }
        g_dev.r4300.cp0.interrupt_unsafe_state = 0;
        translate_event_queue(&g_dev.r4300.cp0, rrt32);
        cp0_regs[CP0_COUNT_REG] = rrt32;
        break;
    case CP0_ENTRYHI_REG:
        cp0_regs[CP0_ENTRYHI_REG] = rrt32 & UINT32_C(0xFFFFE0FF);
        break;
    case CP0_COMPARE_REG:
        cp0_update_count();
        remove_event(&g_dev.r4300.cp0.q, COMPARE_INT);
        add_interrupt_event_count(&g_dev.r4300.cp0, COMPARE_INT, rrt32);
        cp0_regs[CP0_COMPARE_REG] = rrt32;
        cp0_regs[CP0_CAUSE_REG] &= ~CP0_CAUSE_IP7;
        break;
    case CP0_STATUS_REG:
        if((rrt32 & CP0_STATUS_FR) != (cp0_regs[CP0_STATUS_REG] & CP0_STATUS_FR))
        {
            shuffle_fpr_data(cp0_regs[CP0_STATUS_REG], rrt32);
            set_fpr_pointers(rrt32);
        }
        cp0_regs[CP0_STATUS_REG] = rrt32;
        cp0_update_count();
        ADD_TO_PC(1);
        check_interrupt(&g_dev.r4300);
        g_dev.r4300.cp0.interrupt_unsafe_state = 1;
        if (*cp0_next_interrupt <= cp0_regs[CP0_COUNT_REG]) { gen_interrupt(); }
        g_dev.r4300.cp0.interrupt_unsafe_state = 0;
        ADD_TO_PC(-1);
        break;
    case CP0_CAUSE_REG:
        if (rrt32 != 0)
        {
            DebugMessage(M64MSG_ERROR, "MTC0 instruction trying to write Cause register with non-0 value");
            *r4300_stop() = 1;
        }
        else { cp0_regs[CP0_CAUSE_REG] = rrt32; }
        break;
    case CP0_EPC_REG:
        cp0_regs[CP0_EPC_REG] = rrt32;
        break;
    case CP0_PREVID_REG:
        break;
    case CP0_CONFIG_REG:
        cp0_regs[CP0_CONFIG_REG] = rrt32;
        break;
    case CP0_WATCHLO_REG:
        cp0_regs[CP0_WATCHLO_REG] = rrt32;
        break;
    case CP0_WATCHHI_REG:
        cp0_regs[CP0_WATCHHI_REG] = rrt32;
        break;
    case CP0_TAGLO_REG:
        cp0_regs[CP0_TAGLO_REG] = rrt32 & UINT32_C(0x0FFFFFC0);
        break;
    case CP0_TAGHI_REG:
        cp0_regs[CP0_TAGHI_REG] = 0;
        break;
    default:
        DebugMessage(M64MSG_ERROR, "Unknown MTC0 write: %d", rfs);
        *r4300_stop()=1;
    }
    ADD_TO_PC(1);
}

/* CP1 load/store instructions */

DECLARE_INSTRUCTION(LWC1)
{
    const unsigned char lslfft = lfft;
    const uint32_t lslfaddr = (uint32_t) r4300_regs()[lfbase] + lfoffset;
    uint64_t temp;
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    ADD_TO_PC(1);
    *memory_address() = lslfaddr;
    g_dev.mem.rdword = &temp;
    read_word_in_memory();
    if (*memory_address()) {
        *((uint32_t*)(r4300_cp1_regs_simple())[lslfft]) = (uint32_t) *g_dev.mem.rdword;
    }
}

DECLARE_INSTRUCTION(LDC1)
{
    const unsigned char lslfft = lfft;
    const uint32_t lslfaddr = (uint32_t) r4300_regs()[lfbase] + lfoffset;
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    ADD_TO_PC(1);
    *memory_address() = lslfaddr;
    g_dev.mem.rdword = (uint64_t*) (r4300_cp1_regs_double())[lslfft];
    read_dword_in_memory();
}

DECLARE_INSTRUCTION(SWC1)
{
    const unsigned char lslfft = lfft;
    const uint32_t lslfaddr = (uint32_t) r4300_regs()[lfbase] + lfoffset;
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    ADD_TO_PC(1);
    *memory_address() = lslfaddr;
    *memory_wword() = *((uint32_t*)(r4300_cp1_regs_simple())[lslfft]);
    write_word_in_memory();
    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SDC1)
{
    const unsigned char lslfft = lfft;
    const uint32_t lslfaddr = (uint32_t) r4300_regs()[lfbase] + lfoffset;
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    ADD_TO_PC(1);
    *memory_address() = lslfaddr;
    *memory_wdword() = *((uint64_t*) (r4300_cp1_regs_double())[lslfft]);
    write_dword_in_memory();
    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(MFC1)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    rrt = SE32(*((int32_t*) (r4300_cp1_regs_simple())[rfs]));
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DMFC1)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    rrt = *((int64_t*) (r4300_cp1_regs_double())[rfs]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CFC1)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (rfs==31)
    {
        rrt32 = SE32((*r4300_cp1_fcr31()));
    }
    if (rfs==0)
    {
        rrt32 = SE32((*r4300_cp1_fcr0()));
    }
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(MTC1)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    *((int32_t*) (r4300_cp1_regs_simple())[rfs]) = rrt32;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DMTC1)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    *((int64_t*) (r4300_cp1_regs_double())[rfs]) = rrt;
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CTC1)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (rfs==31)
    {
        (*r4300_cp1_fcr31()) = rrt32;
        update_x86_rounding_mode(rrt32);
    }
    //if (((*r4300_cp1_fcr31()) >> 7) & 0x1F) printf("FPU Exception enabled : %x\n",
    //                 (int)(((*r4300_cp1_fcr31()) >> 7) & 0x1F));
    ADD_TO_PC(1);
}

/* CP1 computational instructions */

DECLARE_INSTRUCTION(ABS_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    abs_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ABS_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    abs_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ADD_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    add_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft], (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ADD_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    add_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft], (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DIV_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if(((*r4300_cp1_fcr31()) & UINT32_C(0x400)) && *(r4300_cp1_regs_simple())[cfft] == 0)
    {
        DebugMessage(M64MSG_ERROR, "DIV_S by 0");
    }
    div_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft], (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DIV_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if(((*r4300_cp1_fcr31()) & UINT32_C(0x400)) && *(r4300_cp1_regs_double())[cfft] == 0)
    {
        //(*r4300_cp1_fcr31()) |= 0x8020;
        /*(*r4300_cp1_fcr31()) |= 0x8000;
          Cause = 15 << 2;
          exception_general(&g_dev.r4300);*/
        DebugMessage(M64MSG_ERROR, "DIV_D by 0");
        //return;
    }
    div_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft], (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(MOV_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    mov_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(MOV_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    mov_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(MUL_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    mul_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft], (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(MUL_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    mul_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft], (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(NEG_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    neg_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(NEG_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    neg_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SQRT_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    sqrt_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SQRT_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    sqrt_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SUB_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    sub_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft], (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SUB_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    sub_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft], (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(TRUNC_W_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    trunc_w_s((r4300_cp1_regs_simple())[cffs], (int32_t*) (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(TRUNC_W_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    trunc_w_d((r4300_cp1_regs_double())[cffs], (int32_t*) (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(TRUNC_L_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    trunc_l_s((r4300_cp1_regs_simple())[cffs], (int64_t*) (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(TRUNC_L_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    trunc_l_d((r4300_cp1_regs_double())[cffs], (int64_t*) (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ROUND_W_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    round_w_s((r4300_cp1_regs_simple())[cffs], (int32_t*) (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ROUND_W_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    round_w_d((r4300_cp1_regs_double())[cffs], (int32_t*) (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ROUND_L_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    round_l_s((r4300_cp1_regs_simple())[cffs], (int64_t*) (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ROUND_L_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    round_l_d((r4300_cp1_regs_double())[cffs], (int64_t*) (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CEIL_W_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    ceil_w_s((r4300_cp1_regs_simple())[cffs], (int32_t*) (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CEIL_W_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    ceil_w_d((r4300_cp1_regs_double())[cffs], (int32_t*) (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CEIL_L_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    ceil_l_s((r4300_cp1_regs_simple())[cffs], (int64_t*) (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CEIL_L_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    ceil_l_d((r4300_cp1_regs_double())[cffs], (int64_t*) (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(FLOOR_W_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    floor_w_s((r4300_cp1_regs_simple())[cffs], (int32_t*) (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(FLOOR_W_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    floor_w_d((r4300_cp1_regs_double())[cffs], (int32_t*) (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(FLOOR_L_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    floor_l_s((r4300_cp1_regs_simple())[cffs], (int64_t*) (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(FLOOR_L_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    floor_l_d((r4300_cp1_regs_double())[cffs], (int64_t*) (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CVT_S_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    cvt_s_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CVT_S_W)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    cvt_s_w((int32_t*) (r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CVT_S_L)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    cvt_s_l((int64_t*) (r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CVT_D_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    cvt_d_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CVT_D_W)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    cvt_d_w((int32_t*) (r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CVT_D_L)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    cvt_d_l((int64_t*) (r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CVT_W_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    cvt_w_s((r4300_cp1_regs_simple())[cffs], (int32_t*) (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CVT_W_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    cvt_w_d((r4300_cp1_regs_double())[cffs], (int32_t*) (r4300_cp1_regs_simple())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CVT_L_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    cvt_l_s((r4300_cp1_regs_simple())[cffs], (int64_t*) (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(CVT_L_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    cvt_l_d((r4300_cp1_regs_double())[cffs], (int64_t*) (r4300_cp1_regs_double())[cffd]);
    ADD_TO_PC(1);
}

/* CP1 relational instructions */

DECLARE_INSTRUCTION(C_F_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_f_s();
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_F_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_f_d();
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_UN_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_un_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_UN_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_un_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_EQ_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_eq_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_EQ_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_eq_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_UEQ_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_ueq_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_UEQ_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_ueq_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_OLT_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_olt_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_OLT_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_olt_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_ULT_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_ult_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_ULT_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_ult_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_OLE_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_ole_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_OLE_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_ole_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_ULE_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_ule_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_ULE_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    c_ule_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_SF_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (isnan(*(r4300_cp1_regs_simple())[cffs]) || isnan(*(r4300_cp1_regs_simple())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_sf_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_SF_D)
{
    if (isnan(*(r4300_cp1_regs_double())[cffs]) || isnan(*(r4300_cp1_regs_double())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_sf_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_NGLE_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (isnan(*(r4300_cp1_regs_simple())[cffs]) || isnan(*(r4300_cp1_regs_simple())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_ngle_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_NGLE_D)
{
    if (isnan(*(r4300_cp1_regs_double())[cffs]) || isnan(*(r4300_cp1_regs_double())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_ngle_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_SEQ_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (isnan(*(r4300_cp1_regs_simple())[cffs]) || isnan(*(r4300_cp1_regs_simple())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_seq_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_SEQ_D)
{
    if (isnan(*(r4300_cp1_regs_double())[cffs]) || isnan(*(r4300_cp1_regs_double())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_seq_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_NGL_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (isnan(*(r4300_cp1_regs_simple())[cffs]) || isnan(*(r4300_cp1_regs_simple())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_ngl_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_NGL_D)
{
    if (isnan(*(r4300_cp1_regs_double())[cffs]) || isnan(*(r4300_cp1_regs_double())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_ngl_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_LT_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (isnan(*(r4300_cp1_regs_simple())[cffs]) || isnan(*(r4300_cp1_regs_simple())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_lt_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_LT_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (isnan(*(r4300_cp1_regs_double())[cffs]) || isnan(*(r4300_cp1_regs_double())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_lt_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_NGE_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (isnan(*(r4300_cp1_regs_simple())[cffs]) || isnan(*(r4300_cp1_regs_simple())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_nge_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_NGE_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (isnan(*(r4300_cp1_regs_double())[cffs]) || isnan(*(r4300_cp1_regs_double())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_nge_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_LE_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (isnan(*(r4300_cp1_regs_simple())[cffs]) || isnan(*(r4300_cp1_regs_simple())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_le_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_LE_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (isnan(*(r4300_cp1_regs_double())[cffs]) || isnan(*(r4300_cp1_regs_double())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_le_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_NGT_S)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (isnan(*(r4300_cp1_regs_simple())[cffs]) || isnan(*(r4300_cp1_regs_simple())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_ngt_s((r4300_cp1_regs_simple())[cffs], (r4300_cp1_regs_simple())[cfft]);
    ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(C_NGT_D)
{
    if (check_cop1_unusable(&g_dev.r4300)) { return; }
    if (isnan(*(r4300_cp1_regs_double())[cffs]) || isnan(*(r4300_cp1_regs_double())[cfft]))
    {
        DebugMessage(M64MSG_ERROR, "Invalid operation exception in C opcode");
        *r4300_stop()=1;
    }
    c_ngt_d((r4300_cp1_regs_double())[cffs], (r4300_cp1_regs_double())[cfft]);
    ADD_TO_PC(1);
}
